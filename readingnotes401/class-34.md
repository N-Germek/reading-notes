# Django API Deployments

## Best Practices for Django Configuration

Some of the best practices include having a plan to manage issues.  These issues include different environments, sensitive data, sharing settings between team members, and understanding and establishing the logic in your django settings.py.

Some of the approaches for configuring your settings are below:

- settings_local.py: this will protect your secrets since they are not in your VSC, however you may lose some of the Django environment settings. Since settings.py is a python code, settings_local.py may not have obvious logic. Additionally, you will need the additional work of a setting_local.example in your VCS to share the default Django configurations.  An example of this file is below:

```python
ALLOWED_HOSTS = ['localhost']
DEBUG = True
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'local_db',
        'HOST': '127.0.0.1',
        'PORT': '5432',
    }
}
```

- separate settings file for each environment. You would create a settings package with multiple files that can be shared with developers, and you would specify which django configuration you would use by setting an additional parameter. Using this setup, all environments are in the VCS. You will need to handle secret passwords and tokens differently and inheritance is harder to trace. An example of the file structure and file are below:

```python
settings/
   ├── __init__.py
   ├── base.py
   ├── ci.py
   ├── local.py
   ├── staging.py
   ├── production.py
   └── qa.py
```

from settings/local.py:

```python
from .base import *


ALLOWED_HOSTS = ['localhost']
DEBUG = True
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'local_db',
        'HOST': '127.0.0.1',
        'PORT': '5432',
    }
}
```

Django configuration command:

```python
python manage.py runserver --settings=settings.local
```

- you can use environment variables in django. You would need to handle key error exceptions and convert types manually. However, the configuration is separate from the code, you have environment parity, there is no inheritance, so it has cleaner code, and there is a theoretical grounding for the variables. An example with a KeyError fix in a custom wrapper is below:

```python
import os

from django.core.exceptions import ImproperlyConfigured


def get_env_value(env_variable):
    try:
      	return os.environ[env_variable]
    except KeyError:
        error_msg = 'Set the {} environment variable'.format(var_name)
        raise ImproperlyConfigured(error_msg)


SECRET_KEY = get_env_value('SECRET_KEY')
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': get_env_value('DATABASE_NAME'),
        'HOST': get_env_value('DATABASE_HOST'),
        'PORT': int(get_env_value('DATABASE_PORT')),
    }
}
```

The 12 Factors of easy web deployment created by Heroku with the main rule to store configuration in the environment are as follows:

- Codebase
- Dependencies
- Config
- Backing services
- Build, release, run
- Processes
- Port binding
- Concurrency
- Disposability
- Dev/prod parity
- Logs
- Admin processes

Further information is located on [12factor.net](https://12factor.net/).

django-environ is the preferred environment to store these variables since os.environ could require more of a build out to handle errors.

An example of the settings.py module after implementing django-environ would look similar to the below:

```python
import environ


root = environ.Path(__file__) - 3  # get root of the project
env = environ.Env()
environ.Env.read_env()  # reading .env file

SITE_ROOT = root()

DEBUG = env.bool('DEBUG', default=False)
TEMPLATE_DEBUG = DEBUG

DATABASES = {'default': env.db('DATABASE_URL')}

public_root = root.path('public/')
MEDIA_ROOT = public_root('media')
MEDIA_URL = env.str('MEDIA_URL', default='media/')
STATIC_ROOT = public_root('static')
STATIC_URL = env.str('STATIC_URL', default='static/')

SECRET_KEY = env.str('SECRET_KEY')

CACHES = {'default': env.cache('REDIS_CACHE_URL')}
```

with the .env file looking like this:

```python
DEBUG=True
DATABASE_URL=postgres://user:password@db.example.com:5432/production_db?sslmode=require
REDIS_CACHE_URL=redis://user:password@cache.example.com:6379/1
SECRET_KEY=Some-Autogenerated-Secret-Key
```

You can split your environment by source versus environments with each module setup as a package. Below is the example of the file structure, __init__.py file.

```python
project/
├── apps/
├── settings/
│   ├── __init__.py
│   ├── djano.py
│   ├── project.py
│   └── third_party.py
└── manage.py
```

```python
from .django import *       # All Django related settings
from .third_party import *  # Celery, Django REST Framework & other 3rd parties
from .project import *      # You custom settings
```

```python
project/
├── apps/
├── settings/
│   ├── project
│   │   ├── __init__.py
│   │   ├── custom_module_foo.py
│   │   ├── custom_module_bar.py
│   │   └── custom_module_xyz.py
│   ├── third_party
│   │   ├── __init__.py
│   │   ├── celery.py
│   │   ├── email.py
│   │   └── rest_framework.py
│   ├── __init__.py
│   └── djano.py
└── manage.py
```

Final best practice would be to set clear easily identifiable naming conventions on your variables associated with your secret keys. Follow these three rules to set consistent expectations for yourself and your team:

1. give meaningful names
2. always use the prefix with the project name in settings
3. write descriptions of the settings in comments

## What is SSH

To begin SSH is the Secure Shell Protocol governing how users access, control or modify their remote servers over the internet.  The user is the account that you want to access and the host is the computer you would like to access.  It will prompt for a password and once entered and validated you will be greeted with a remote terminal window. The terminal command to use it is:

```python
ssh {user}@{host}
```

### Encryption

Symmetrical Encryption (often referred to as shared key or shared secret) is when the host and the client both posses a secret key to access the data being transferred. Anyone with the key can access the data.

- usually, one sometimes a pair of keys are created

- the entire communication in an SSH session are encrypted

- client and server develop the secret key with an agreed upon method using a key exchange algorithm

- the key is never disclosed to a third party

- a variety of cyphers exist and the host and client decide upon the cypher before beginning the connection

Asymmetric Encryption uses two separate keys (public key and private key), and they form a public-private key pair. The public or private key can only be used by the individual with the other key to the pair.

- the keys are paired using complex mathematical algorithms

- this encryption is NOT used to encrypt an entire session

- before the connection, both parties create temporary key pairs to share their individual private and public key to make the secret key pair

- once connection is made, the server will establish, generate the challenge and send it to the client, if client successfully decrypts, then the keys are validated as the pair

- after that validation, SSH session can now begin

Hashing is the form of cryptography in which it is never meant to be decrypted. Hashing generates a unique value with no clear trend of a fixed length that cannot be reversed.

- the client will hold the input and then generate a hash and compare that value

- completed using HMAC (Hash-based Message Authentication Codes) which ensures command received is untampered

- encryption algorithm and suitable message algorithm are selected at the same time

- each message must contain a MAC calculated by the key, packet sequence number and message contents

SSH operates on TCP port 22 by default. The port can be changed if needed. The host listens on the port for the incoming connection, authenticates the client and opening the shell environment if it is successful.

## Things I want to know more about

### Resources

[Django Settings and Best Practices](https://djangostars.com/blog/configuring-django-settings-best-practices/)

[SSH Tutorial](https://www.hostinger.com/tutorials/ssh-tutorial-how-does-ssh-work)

### Links

- >[Advanced Software Development](README.md)
